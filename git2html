#!/usr/bin/perl -w
use strict;
use File::Path qw(make_path remove_tree);
use Algorithm::Diff qw(sdiff);
use HTML::Entities;

#my $gitdir = '/home/mitch/git/uzepede/';
#my $file   = 'TODO';
#my $gitdir = '/home/mitch/git/dwm-mitch/';
#my $file   = 'dwm/dwm.c';
#my $gitdir = '/home/mitch/git/git2html/';
#my $file   = 'git2html';
my $gitdir = '/home/mitch/git/git2html-test/';
my $file   = 'script.pl';
my $output = './out';
my $tabwidth = 8;

print "git repo   = `$gitdir'\n";
print "file       = `$file'\n";
print "output dir = `$output'\n";

$|++;

#####################################################################################

# CSS descriptions

my $css = '';


$css .= <<EOF;
/*
the following snippet for .triangle-border is
taken from here:
*/
/* ------------------------------------------
PURE CSS SPEECH BUBBLES
by Nicolas Gallagher
- http://nicolasgallagher.com/pure-css-speech-bubbles/

http://nicolasgallagher.com
http://twitter.com/necolas
 
Created: 02 March 2010
Version: 1.2 (03 March 2011)

Dual licensed under MIT and GNU GPLv2 Â© Nicolas Gallagher 
------------------------------------------ */
.triangle-border {
	position:relative;
	padding:15px;
	margin:1em 0 3em;
	border:5px solid #5a8f00;
	color:#333;
	background:#fff;
	/* css3 */
	-webkit-border-radius:10px;
	-moz-border-radius:10px;
	border-radius:10px;
}

.triangle-border:before {
	content:"";
	position:absolute;
	bottom:-20px; /* value = - border-top-width - border-bottom-width */
	left:40px; /* controls horizontal position */
    border-width:20px 20px 0;
	border-style:solid;
    border-color:#5a8f00 transparent;
    /* reduce the damage in FF3.0 */
    display:block; 
    width:0;
}

/* creates the smaller  triangle */
.triangle-border:after {
	content:"";
	position:absolute;
	bottom:-13px; /* value = - border-top-width - border-bottom-width */
	left:47px; /* value = (:before left) + (:before border-left) - (:after border-left) */
	border-width:13px 13px 0;
	border-style:solid;
	border-color:#fff transparent;
    /* reduce the damage in FF3.0 */
    display:block; 
    width:0;
}

EOF
    ;

$css .= <<EOF;
.navbar {
  background:#eca;
  padding:5px;
}

.button {
  background:#fff;
  margin:3px;
  padding:1px;
  font-weight:bolder;
}

.signature {
    margin-top:-30px;
    margin-bottom:30px;
    font-family:Georgia,Serif;
    font-style:italic;
}

.diff {
    border-style: solid none;
    border-width: 20px;
    border-color: #ccc;
  margin: 20px 0;
  padding: 20px 0;
}

.code {
    border-style: none solid;
    border-width: 2px;
    border-color: #ccc;
  margin: 0;
  padding: 0 5px;
    white-space: no-wrap;
}

.red {
  color:red;
 background:#fcc;
}

.green {
  color:green;
 background:#cfc;
}

.blue {
  color:blue;
 background:#ccf;
}

EOF
    ;

#####################################################################################

# build git commandline
sub git_cmdline(@)
{
    return join(' ', ('git', "--work-tree=\"${gitdir}\"", "--git-dir=\"${gitdir}/.git\"", @_) );
}

# stupid simple git wrapper
sub git(@)
{
    my @ret = ();
    my $cmd = git_cmdline(@_);
    open GIT, "$cmd |" or die "can't execute `$cmd': $!\n";
    while (my $line = <GIT>) {
	chomp $line;
	push @ret, $line;
    }
    close GIT or die "can't close `$cmd': $!\n";
    return @ret;
}

# format ASCII to HTML
sub htmlize(@)
{
    my $ret = join "\n", @_;
    $ret = encode_entities($ret, "<>&\"'");
    $ret =~ s/\n/<br>/g;
    $ret =~ s/^ /&nbsp;/gm;
    $ret =~ s/  /&nbsp;&nbsp;/g;

    return $ret;
}

# print HTML navbar
sub format_html_navbar($$)
{
    my ($id, $max_id) = (@_);
    my $ret = '<div class="navbar">';

    $ret .= '<span class="button">';
    if ($id > 0) {
	$ret .= sprintf '<a href="%04d.html">&lt;&lt;&lt;</a> ', ($id - 1);
    } else {
	$ret .= '&lt;&lt;&lt; ';
    }
    $ret .= '</span>';

    $ret .= '<span class="button">';
    $ret .= '<a href="../index.html">^^^</a> ';
    $ret .= '</span>';

    $ret .= '<span class="button">';
    if ($id < $max_id - 1) {
	$ret .= sprintf '<a href="%04d.html">&gt;&gt;&gt;</a> ', ($id + 1);
    } else {
	$ret .= '&gt;&gt;&gt; ';
    }
    $ret .= '</span>';

    $ret .= sprintf '(%04d/%04d)', $id+1, $max_id;

    $ret .= '</div>';
    return $ret;
}

# print HTML header
sub format_html_header()
{
    my $ret = "<!DOCTYPE html>\n";
    $ret .= '<html><head>';
    $ret .= "<style>\n$css\n</style>";
    $ret .= '</head><body>';
    return $ret;
}

# print HTML header
sub format_html_footer()
{
    my $ret .= '</body></html>';
    return $ret;
}

#####################################################################################

# prepare output dir
remove_tree($output);
make_path($output);


# read all branches
printf "\nreading branches...\n";
my %branch = 
    map { $_ => {} }
        sort
            map { substr ($_, 2) }
                git('branch');
printf "%s\n", 'x' x scalar keys %branch;


# read all commits
printf "\nreading commits...\n";
foreach my $branch (keys %branch) {

    # get all commits from log
    my @commits =
	map { (split(/ /, $_, 2))[0] }
            git('log', '--format=oneline', $branch, '--', $file);

    $branch{$branch} = {
	BRANCH  => $branch,
	HEAD    => $commits[0],
	COMMITS => \@commits
    };

    print "x";
}
print "\n";

    
# try to remove duplicate commits
printf "\npruning commits...\n";
foreach my $branch (keys %branch) {

    # get the heads of all other branches
    my @heads = 
	map { $branch{$_}->{HEAD} }
            grep { $_ ne $branch }
                keys %branch;

    # prune commits when reaching the HEAD of another branch
    # also reverse the commits
    my @commits;
    foreach my $commit ( @{$branch{$branch}->{COMMITS}} ) {
	unshift @commits, $commit;
	last if (grep { $_ eq $commit } @heads) > 0;
    }
	
    # store pruned commit list
    $branch{$branch}->{COMMITS} = \@commits;

    print "x";
}
print "\n";

    
# remove branches without changes
printf "\npruning branches...\n";
{
    my %branch_ =
	map { $_ => $branch{$_} }
            grep { @{$branch{$_}->{COMMITS}} > 1 }
                keys %branch;
    %branch = %branch_;
}
printf "%s\n", 'x' x scalar keys %branch;

    
# process all branches
foreach my $branch (keys %branch) {
    print "\nprocessing branch <$branch>...\n";

    my @commits = @{$branch{$branch}->{COMMITS}};

    my $outdir = "${output}/${branch}";
    make_path($outdir);

    # extract all unique file revisions

    foreach my $commit (@commits) {

	my $cmd = git_cmdline('cat-file', 'blob', "${commit}:${file}");
	system( "$cmd | expand -t $tabwidth > \"$outdir/$commit\"" );

    }

    # create individual diffs

    my $lastcommit = undef;
    my $id = 0;
    my $lastfile;
    my $max_id = @commits - 1;
    foreach my $commit (@commits) {
	
	open FILE, '<', "$outdir/$commit" or die "can't open `$outdir/$commit': $!";
	my $curfile = [ <FILE> ];
	chomp @{ $curfile };
	close FILE or die "can't open `$outdir/$commit': $!";

	if ($lastfile) {

	    my $htmlfile = sprintf '%s/%04d.html', $outdir, $id;
	    open HTML, '>', $htmlfile or die "can't open `$htmlfile': $1";

	    print HTML format_html_header();

	    print HTML format_html_navbar($id, $max_id);

	    # print log
	    
	    my @commitlog = git('log', '-n', '1', '--format=format:"%an <%ae>, %ad%n%s%n%n%b"', $commit);
	    my $author = shift @commitlog;

	    print HTML '<div class="triangle-border">'.htmlize(@commitlog).'</div>';
	    print HTML '<div class="signature">'.htmlize($author).'</div>';

	    # do the dirty diff work

	    my (@left, @right);

	    foreach my $hunk (sdiff($lastfile, $curfile)) {

		my ($type, $left, $right) = @{ $hunk };

		if ($type eq 'c') { # both changed

		    # WE MUST GO DEEEPER!
		    # (and before the htmlize!)

		    my $left__  = '';
		    my $right__ = '';

		    my @hunks = sdiff( [ split(//, $left) ], [ split(//, $right) ] );

		    my $lcolor = 'red';
		    my $rcolor = 'green';

		    # concatenate as much as possible (don't color every single character)
		    {
			my @newhunks;
			my $_type  = '';
			my $_left  = '';
			my $_right = '';
			foreach my $hunk_ (@hunks) {
			    my ($type_, $left_, $right_) = @{ $hunk_ };
			    if ($_type ne $type_) {
				if ($_type ne '') {
				    push @newhunks, [ $_type, $_left, $_right ];
				    $_left = $_right = '';
				}
				$_type = $type_;
			    }
			    $_left  .= $left_;
			    $_right .= $right_;
			}
			if ($_type ne '') {
			    push @newhunks, [ $_type, $_left, $_right ];
			}
			
			@hunks = @newhunks;
		    }

		    # prettify, don't show too much line noise
		    my $changes = 0;
		    my $last = '';
		    foreach my $hunk_ (@hunks) {
			my $type = @{ $hunk_ }[0];
			next if $last eq $type;
			$changes++;
			$last = $type;
		    }
		    if ($changes > 5) {
			$lcolor = $rcolor = 'blue';
		    }

		    foreach my $hunk_ (@hunks) {

			my ($type_, $left_, $right_) = @{ $hunk_ };
			
			$left_  = htmlize( $left_ );
			$right_ = htmlize( $right_ );
			
			if ($type_ eq '-') { # left is removed
			    $left__ .=  "<span class=\"${lcolor}\">$left_</span>";
			    $right__ .= $right_;
			    
			} elsif ($type_ eq '+') { # right is added
			    $left__  .= $left_;
			    $right__ .= "<span class=\"${rcolor}\">$right_</span>";
			    
			} elsif ($type_ eq 'u') { # unchanged
			    $left__  .= $left_;
			    $right__ .= $right_;
			    
			} elsif ($type_ eq 'c') { # both changed
			    
			    $left__  .= "<span class=\"blue\">$left_</span>";
			    $right__ .= "<span class=\"blue\">$right_</span>";
			}
		    }

		    push @left,  $left__;
		    push @right, $right__;

		} else {

		    $left  = htmlize( $left );
		    $right = htmlize( $right );
		    
		    if ($type eq '-') { # left is removed
			push @left,  "<span class=\"red\">$left</span>";
			push @right, $right;
			
		    } elsif ($type eq '+') { # right is added
			push @left,  $left;
			push @right, "<span class=\"green\">$right</span>";
			
		    } elsif ($type eq 'u') { # unchanged
			push @left,  $left;
			push @right, $right;

		    }
			
		}
	    }

	    print HTML '<table class="diff"><tr><td class="code"><code>';
	    foreach my $line (@left) {
		print HTML "$line<br>\n"
	    }
	    print HTML '</code></td><td class="code"><code>';
	    foreach my $line (@right) {
		print HTML "$line<br>\n"
	    }
	    print HTML '</code></td></tr></table>';

	    print HTML format_html_navbar($id, $max_id);

	    print HTML format_html_footer();

	    close HTML or die "can't close `$htmlfile': $1";

	    $id++;
	}
	$lastfile = $curfile;

	print "x";
    }
    print "\n";

    # clean up unique file revisions

    foreach my $commit (@commits) {
	unlink "$outdir/$commit";
    }

}


# write index.html

my $htmlfile = "${output}/index.html";
open HTML, '>', $htmlfile or die "can't open `$htmlfile': $1";

print HTML format_html_header();

print HTML "<h1>$file</h1>\n";
print HTML '<ul>';
foreach my $branch (keys %branch) {
    printf HTML ("<li><a href=\"%s/0000.html\">%s</a> (%04d)</li>\n",
		 $branch,
		 $branch,
		 @{$branch{$branch}->{COMMITS}} - 1
	);
}
print HTML '</ul>';

print HTML format_html_footer();

close HTML or die "can't close `$htmlfile': $1";
